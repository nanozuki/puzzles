package sudoku

import (
	"fmt"
	"testing"
	"time"
)

func TestSudoku_Solve(t *testing.T) {
	tests := []struct {
		puzzle   string
		solution string
	}{
		{puzzle: "805009304200000000000600009040000000903006800000010070020005000504700080060000400", solution: "875129364296543718431687529147958236953276841682314975328465197514792683769831452"},
		{puzzle: "700390000003000000009040060075000006080000007000000349000006400000700020210005000", solution: "762391584843657192159842763375924816984163257621578349597286431438719625216435978"},
		{puzzle: "000500090030000005000827000100406000090000070280050000405000000700000902000000156", solution: "672531498831649725549827361157496283396218574284753619415962837763185942928374156"},
		{puzzle: "000032057008000090000006004001984072600200000800600549900078005070560000000000000", solution: "496832157218745396753196284531984672649257831827613549962378415374561928185429763"},
		{puzzle: "007100004030070008106000000560300020000010060040090050000000000070002040050030009", solution: "287153694435679218196824375561348927928715463743296851814967532379582146652431789"},
	}
	for i, tt := range tests {
		t.Run(fmt.Sprintf("case %d", i), func(t *testing.T) {
			s := NewFromString(tt.puzzle)
			start := time.Now()
			if !s.Solve() {
				t.Errorf("Sudoku.Solve() = false, want true")
			}
			elapsed := time.Since(start)
			fmt.Printf("Solved puzzle %d in %s\n", i, elapsed)
			if got := s.String(); got != tt.solution {
				t.Errorf(`
Sudoku.Solve() = %v\n
        anwser = %v`, got, tt.solution)
			}
		})
	}
}
